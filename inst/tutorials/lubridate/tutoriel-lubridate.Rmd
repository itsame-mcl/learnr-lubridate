---
title: "Tutorial lubridate"
output: learnr::tutorial
runtime: shiny_prerendered
description: "Tutoriel dédié à l'apprentissage des bases du package de gestion des dates : lubridate"
---

```{r setup, include=FALSE}
library(learnr)
library(lubridate)
knitr::opts_chunk$set(echo = FALSE)
```

## Introduction

Dans la plupart des logiciels et langages de programmation, le temps est considéré comme une simple valeur numérique à partir d'une date de référence.

Pour R, cette "origine des temps" est le 1er janvier 1970, 00:00:00 UTC. En revanche, LibreOffice Calc utilise le 30 décembre 1899 sous Windows et le 1er janvier 1904 sous macOS. Microsoft Excel utilise le 1er janvier 1900... ces différences d'origine complexifient le traitement des données temporelles.

Pour contourner ce problème, les indications temporelles sont souvent stockées sous un format textuel - par exemple "12/07/2014" - mais cela rend difficile la réalisation de calculs à partir de ces dates.

Les fonctionnalités de base de R permettent en partie de traiter ces questions, mais au prix de contraintes de syntaxe et d'un manque de souplesse.

Le package **lubridate** permet d'importer ou de générer des données temporelles, de réaliser des calculs de durées ou d'intervalles et d'accéder facilement aux différents éléments d'une date.

L'installation et le chargement s'effectuent à l'aide la commande suivante :

```{r installpack, message=FALSE, warning=FALSE, echo=TRUE}
#install.packages("lubridate")
library(lubridate)
```

## Importation de dates

L'importation de données temporelles avec **lubridate** s'effectue en deux temps :

* Identification de l'ordre dans lequel les éléments apparaissent dans la donnée source : année (**y**), mois (**m**), jour (**d**), heure (**h**), minute (**m**), seconde (**s**).
* Appel de la fonction de **lubridate** reprenant l'ordre de ces éléments : 
  + **ymd_hms**() - Année Mois Jour Heure Minute Seconde -
  + **dmy**() - Jour Mois Année -
  + **dmy_hms**() - Jour Mois Année Heure Minute Seconde -
  + Toute autre combinaison avec **y**, **m**, **d**, **h**, **m** et **s**.
  
Les dates retournées par toutes les fonctions de **lubridate** sont au format "yyyy-mm-dd" (dd : day, mm : month, yyyy : year).
  
**Lubridate** posède également des fonctions **now**() et **today**() donnant respectivement la date du jour avec ou sans l'heure.

### Exemples

```{r, echo=TRUE, comment=''}
date_1 <- ("25/12/2015") # Jour/Mois/Année
lubridate1 <- dmy(date_1)
lubridate1 # Notre date est bien importée au format yyyy-mm-dd

date_2 <- ("2020-24-12") # Année/Jour/Mois
lubridate2 <- ydm(date_2)
lubridate2

date_3 <- ("12 Janvier 2021 à 15:30:05") # Jour/Mois/Année/Heure/Minute/Seconde
lubridate3 <- dmy_hms(date_3)
lubridate3

now() # Date et heure actuelle
today() # Date actuelle seulement
```

### Exercices 

Pour chaque exercice, choisissez la fonction du package **lubridate** permettant l'import correct de la date. 

```{r dateimport1, exercise=TRUE, exercise.lines = 3}
date_1 <- ("13/01/2021")
lubridate1 <- # ICI code pour importer la date
lubridate1
```
```{r dateimport1-solution}
date_1 <- ("13/01/2021")
lubridate1 <- dmy(date_1)
lubridate1
```
```{r dateimport2, exercise=TRUE, exercise.lines = 3}
date_2 <- ("25-2021-10")
lubridate2 <- # ICI code pour importer la date
lubridate2
```
```{r dateimport2-solution}
date_2 <- ("25-2021-10")
lubridate2 <- dym(date_2)
lubridate2
```
```{r dateimport3, exercise=TRUE, exercise.lines = 3}
date_3 <- ("25 Février 2018 à 12H30")
lubridate3 <- # ICI code pour importer la date
lubridate3
```
```{r dateimport3-solution}
date_3 <- ("25 Février 2018 à 12H30")
lubridate3 <- dmy_hm(date_3)
lubridate3
```

```{r importquiz}
quiz(
  question("Quel est le format de date retourné par les fonctions lubridate ?",
    answer("yyyy-dd-mm"),
    answer("dd-mm-yyyy"),
    answer("yyyy-mm-dd", correct = TRUE),
    answer("dd-mm-yy"),
    allow_retry = TRUE
  )
)
```

## Conversion entre les fuseaux horaires

La liste des fuseaux horaires proposés par le package **lubridate** est disponible à l'aide de la fonction **OlsonNames()**.

L'équivalent d'une date/heure dans un autre fuseau horaire peut-être obtenu à l'aide de la fonction **with_tz**.

### Exemples

```{r, message=FALSE, warning=FALSE, echo=TRUE, comment=''}
head(OlsonNames())
```

```{r, message=FALSE, warning=FALSE, echo=TRUE, comment=''}
# Importation de la date (Cf. paragraphe précédent)
date <- dmy_hm("25 Février 2018 à 12H30")

# Conversion dans le fuseau horaire de Los Angeles
date_convertie <- with_tz(date, "America/Los_Angeles")
date_convertie

# Conversion dans le fuseau horaire de Abidjan
date_convertie2 <- with_tz(date, "Africa/Abidjan")
date_convertie2
```

### Exercices
Convertissez la date suivante dans le fuseau horaire de Asmera :
```{r dateconvert1, exercise=TRUE, exercise.lines = 3}
date_1 <- dmy_hm("25 Février 2018 à 12H30")
date_convertie_1 <- # ICI code pour convertir la date dans le fuseau horaire de Asmera
date_convertie_1
```
```{r dateconvert1-solution}
date_1 <- dmy_hm("25 Février 2018 à 12H30")
date_convertie_1 <- with_tz(date_1, "Africa/Asmera")
date_convertie_1
```
Convertissez maintenant la date dans le fuseau horaire de Los Angeles :
```{r dateconvert2, exercise=TRUE, exercise.lines = 3}
date_2 <- dmy_hm("25 Février 2018 à 12H30")
date_convertie_2 <- # ICI code pour convertir la date dans le fuseau horaire de Los Angeles
date_convertie_2
```
```{r dateconvert2-solution}
date_convertie_2 <- with_tz(date_2, "America/Los_Angeles")
date_convertie_2
```

## Manipulation des dates 

[Comment ajouter un fichier CSS !? ](https://education.rstudio.com/blog/2020/05/learnr-for-remote/#2-customized-hints-and-solutions)

Les dates sont des objets que l'on peut manipuler. Nous pouvons accèder aux différents éléments d'une date : année, mois, jour, heure, etc. Comme tout autre objet R, nous pouvons les modifier mais également faire des calculs.

### Accès aux éléments d'une date

Dans le package `lubridate` il existe de nombreuses fonctions pour accéder aux différents éléments d'une date.

Voici une liste non exhausive des élements d'une date que l'on peut extraire :

|  Date | Annee | Mois | Semaine | Jour | Heure |
|:-----:|:-----:|:-----:|:-----:|:----:|:---:|
|`date`|`year` `leap_year` `semester` `quarter`|`month`|`week`|`day` `wday` `qday` `yday` `hour`|`minute` `second` `am` `pm` `dst`|

**Date**

* `date` : date au format année-mois-jour
* `month` : mois
* `week` : numéro de la semaine 

**Annee**

* `year` : année
* `leap_year` : est-ce une année bisextile ?
* `semester` : numéro du semestre
* `quarter` : numéro du trimestre


**Jour** 

* `hour` : heure
* `day` : jour du mois
* `wday` : jour de la semaine
* `qday` : jour du trimestre
* `yday` : jour de l'année
  

**Heure**

* `minute` : minute
* `second` : seconde
* `am` : est-ce le matin ?
* `pm` : est-ce l'après-midi ?
* `dst` : est-ce l'heure d'été ?

Toutes les fonctions prennent au moins un paramètre : une date. Par exemple si on veut utiliser la fonction heure on utilisera `hour(x)` où `x` est une date dont on veut connaître l'heure. La majorité ces fonctions partagent les mêmes paramètres que nous verrons plus loin dans cette section.

Prenons un exemple que nous garderons dans toute la suite de cette section comme le 1er septembre 1999 à 11h 59m 59s. Ici on affecte à la variable `date` la fonction suivante : `dmy_hms("01-09-1999 11:59:59")` et la convertissons en date comme vu précédemment. Par exemple, si l'on veut extraire l'heure, le jour, le numéro de la semaine et l'année du 1er septembre 1999 on utilisera les commandes suivantes :


```{r exemple-1999-09_01, include=FALSE}
date <- dmy_hms("01-09-1999 11:59:59")
```

```{r examples-data-management, echo=TRUE, include=TRUE, comment=''}
# l'heure
hour(date)
# le jour
day(date) 
# le numéro de la semaine
week(date) 
# l'année
year(date) 
```

Au lieu d'un numéro on pourrait vouloir connaître le mois ou encore le jour (en lettres). Pour cela on dispose de deux paramètres : `label` et `abbr` qui prennent en paramètre un booléen. Par défaut `label` est défini à `FALSE` et `abbr` est défini à `TRUE`. `label` permet d'afficher un texte abbrévié et `abbr` permet de dire si l'on veut que le texte soit abbrévié ou non. Mais **attention ces options ne fonctionnent pas sur toutes les fonctions**. Entre autres, ces options seront disponibles pour `wday` mais pas pour `day`. Illustrons cela par des exemples.

```{r examples-labels-abbr, echo=TRUE, comment=''}
# nombre
month(date) 
# label abrévié
month(date, label = T)
# label non abrévié
month(date, label = T, abbr = F) 
```

Cela affiche également les autres mois et l'on voit bien qu'ils sont ordonnés selon un ordre chronologique.

A cela s'ajoute deux autres options : `week_start` et `locale`. L'option `week_start` défini le début de la semaine. Par convention, -1 correspond à lundi et 7 correspond à dimanche. Quant à `locale`, il s'agit de définir les noms des jours ou mois (en fonction de la langue).

Deux fonctions ont un paramètre supplémentaire. Il s'agit des fonctions `quarter` et `semester` qui ont la syntaxe suivante : `fonction(x, with_year = FALSE)`. Le second paramètre indique si l'on veut concaténer ou non le numéro du semestre avec l'année. Par exemple, si on veut connaître le semestre du 1er janvier 2020 en utilisant `with_year = TRUE` on obtiendra 2020.1 car le 01/01/2020 est un jour du premier semestre.

Voici quelques exemples avec notre date du 01/09/1999.

```{r examples-quarter-semester, echo=TRUE, include=TRUE, comment=''}
# trimestre sans année
quarter(date, with_year = F) 
# trimestre avec année
quarter(date, with_year = T) 
# semestre sans année
semester(date, with_year = F) 
# semestre avec année
semester(date, with_year = T) 
```


On remarque que toutes les fonctions retournent un nombre qui correspond soit à un numéro soit à un nombre d'heures, de jours, etc. (ou avec un label). Seules les fonctions `leap_year`, `am`, `pm` et `dst` renvoient un booléen (`True` ou `False`) comme le montrent les exemples ci-dessous.

```{r exemples-data-management-bool, echo=TRUE, include=TRUE, comment=''}
# année bisextile ?
leap_year(date) 
# matin ?
am(date) 
# après-midi ?
pm(date) 
# heure d'été ?
dst(date) 
```


**NB** Il existe également quelques variantes pour permettre de mettre une date au format ISO comme `isoyear` ou `isomonth`.

En manipulant la fonction `month` il est également possible d'afficher tous les mois de l'année. En effet, si on prend le mois de janvier auquel on ajoute les mois restant au travers de la ligne de commande `month(dmy("01-01-2021") + months(0:11), label = T, abbr = F)`. Le resultat sera `janvier février mars avril mai juin juillet août septembre octobre novembre décembre`. Il est également possible de faire ces manipulations sur toutes les fonctions qui prennent en paramètre un label.

```{r quiz-compenents-date}
quiz(
  question("Quel(s) paramètre(s) prend la fonction `day`?",
    answer("week_start"),
    answer("label"),
    answer("une date", correct = TRUE),
    answer("locaale"),
    answer("abbr"),
    allow_retry = TRUE
  ),
  question("Parmi ces commandes, lequelles sont vraies?",
    answer("1", correct = TRUE),
    answer("2"),
    answer("3"),
    answer("4", correct = TRUE),
    allow_retry = TRUE
  )
)
```


#### Exercices

Ecrire la date du 15 février 1970 puis à l'aide d'une fonction extraire le mois (numéro et nom).
```{r 15-02-1970-month, exercise=TRUE, exercise.lines = 5}

```

```{r 15-02-1970-month-solution}
date <- dmy("15-02-1970")
month(date, label = T)
month(date, label = T, abbr = F)
```

Afficher tous les jours de la semaine à l'aide d'une commande en commençant par lundi. (*Remarque* Le 1er février 2021 est un lundi.)
```{r days, exercise=TRUE, exercise.lines = 3}

```

```{r days-solution}
wday(dmy("01-02-2021") + wday(0:6), label = T, abbr = F)
```

Ennoncé
```{r day, exercise=TRUE, exercise.lines = 5}
date <- dmy("10-12-1990")
```

```{r day-solution}
day(date)
```



### Modification d'une date (Alanna)

**Parler de la fonction UPDATE ! **

Exemples de manipulations de dates

`years(2017) + months(2) + days(3)`

`today() - (months(2) + days(3))`

## Durées
Jusqu'à présent, l'ensemble des opérations présentées s'effectuent sur des **périodes**, c'est à dire des variations temporelles au sens du temps *légal*. Cependant, le package **lubridate** permet également de réaliser des calculs sur des **durées**.

Une **durée** représente une quantité exacte de secondes. Elle ne dépend pas passage à l'heure d'été ou d'hiver, ni des secondes intercalaires qui sont parfois ajoutées pour prendre en compte la durée réelle de la rotation de la terre ou des années bisextiles.

Les fonctions permettant de manipuler les durées portent un nom similaire à celles dédiées aux périodes, puisqu'elles sont préfixées par la lettre **d**. Par rapport aux fonctions permettant d'accéder aux éléments d'une date, on ajoute également un **s** en suffixe, comme pour les périodes. Par exemple :
```{r examples-durations, echo=TRUE, comment=''}
# heures
dd1 <- dhours(4)
dd1
# semaines
dd2 <- dweeks(2)
dd2
# millisecondes
dd3 <- dmilliseconds(2850)
dd3
```

Comme une période, une durée peut être ajoutée ou retranchée à une date, le résultat est alors reconverti en temps légal :
```{r examples-calc-durations, echo=TRUE, comment=''}
# Ajout d'une durée de 2 heures, le 28 mars 2021 02h00 étant le début de l'heure d'été
cd1 <- ymd_hm("2021-03-28 01:30",tz="Europe/Paris") + dhours(2)
cd1 # On remarque que l'heure affichée est 04h30 et non 03h30
# Retrait d'une durée d'un an, l'année 2020 étant bisextile
cd2 <- ymd_hm("2020-07-01 00:00") - dyears(1)
cd2 # la durée physique d'une année est de 365 jours et 6 heures, d'où l'heure affichée de 18h00
# Ajout d'une durée de 120 minutes, le 31 octobre 2021 03h00 étant le début de l'heure d'hiver 
cd3 <- ymd_hm("2021-10-31 01:30",tz="Europe/Paris") + dminutes(120)
cd3 # On remarque que l'heure affichée est 02h30 et non 03h30
```

A noter qu'en l'absence de précision d'un fuseau horaire, le temps UTC s'applique. Or, ce dernier est insensible au passage à l'heure d'été ou d'hiver.
```{r examples-calc-durations-utc, echo=TRUE, comment=''}
# Ajout d'une durée de 2 heures, le 28 mars 2021 02h00 étant le début de l'heure d'été
cd4 <- ymd_hm("2021-03-28 01:30") + dhours(2)
cd4 # Ici, l'heure affichée est 03h30, car le temps UTC ne varie pas
```

```{r quiz-compenents-durations}
quiz(
  question("Lesquelles de ces instructions correspondent à une durée de 10800 secondes ?",
    answer("dhours(3)", correct = TRUE),
    answer("minutes(180)"),
    answer("second(10800)"),
    answer("ddays(1/8)", correct = TRUE),
    answer("dhours(4) - dminutes(60)", correct = TRUE),
    allow_retry = TRUE
  ),
  question("Sachant que le passage de l'heure d'hiver à l'heure d'été a eu lieu le dimanche 31 mars 2019 à 02h00, quel est le résultat de l'opération ymd(\"2019-03-30\", tz=\"Europe/Paris\") + ddays(2) ?",
    answer("2019-04-01 CEST"),
    answer("2019-04-01 01:00:00 CEST", correct = TRUE),
    answer("2019-04-01 01:00:00 UTC"),
    answer("2019-04-01 00:00:00 CEST"),
    allow_retry = TRUE
  )
)
```

#### Exercice

A partir du 25 mars 2021, 12h00 (heure de Paris), ajoutez la durée permettant d'arriver au 1er avril 2021, 18h30 (heure de Paris)
```{r durationexo, exercise=TRUE, exercise.lines = 3}
date_depart <-dmy_hm("25/03/2021 12h00", tz="Europe/Paris")
date_arrivee <- # ICI code pour ajouter la durée
date_arrivee
```
```{r durationexo-solution}
date_depart <-dmy_hm("25/03/2021 12h00", tz="Europe/Paris")
date_arrivee <- date_depart + ddays(6) + dhours(5) + dminutes(30)
date_arrivee
```

## Intervalles

Un **intervalle** représente une durée physique entre deux dates. Il peut être déclaré à l'aide de la fonction **interval** ou de la syntaxe **%--%** :
```{r examples-intervals, echo=TRUE, comment=''}
# 1ère syntaxe
i1 <- interval(ymd("2020-09-01"),ymd("2021-05-31"))
i1
# 2ème syntaxe, pour le même intervalle
i2 <- ymd("2020-09-01") %--% ymd("2021-05-31")
i2
```

Il est ensuite possible de déterminer si une date appartient ou non à un intervalle à l'aide de l'opérateur **%within%** :
```{r examples-within, echo=TRUE, comment=''}
# 1er test : le 1er janvier 2021 est inclus dans l'intervalle
test1 <- ymd("2021-01-01") %within% i1
test1
# 2ème test : le 15 juillet 2020 n'est pas inclus dans l'intervalle
test2 <- ymd("2020-07-15") %within% i2
test2
```

D'autres fonctions permettent de comparer des intervalles : **int_aligns** vérifie si deux intervalles partagent une borne (de début ou de fin) tandis que **int_overlaps** détermine si deux intervalles ont au moins une seconde en commun.
```{r examples-align-overlap, echo=TRUE, comment=''}
# Définition de 3 intervalles
i3 <- interval(ymd("2021-01-01"),ymd("2021-02-01"))
i4 <- interval(ymd("2021-01-01"),ymd("2021-03-01"))
i5 <- interval(ymd("2021-01-15"),ymd("2021-02-15"))
# i3 et i4 ont la borne de début du 1er janvier 2021 en commun
test3 <- int_aligns(i3,i4)
test3
# i3 et i5 ont des secondes en commun
test4 <- int_overlaps(i3,i5)
test4
```

Citons encore **int_length** qui permet d'obtenir la longueur (en secondes) d'un intervalle et **int_shift** qui décale un intervalle en fonction d'une période donnée :
```{r examples-length-shift, echo=TRUE, comment=''}
# Quelle est la longueur de i3 ?
int_length(i3)
# Décalage de i4 d'une période de 15 jours
i6 <- int_shift(i4,days(15))
i6
```

```{r quiz-intervals}
quiz(
  question("Lesquelles de ces instructions créent un intervalle du 1er au 8 janvier 2021 ?",
    answer("ymd(2021-01-01)--ymd(2021-01-08)"),
    answer("ymd(2021-01-01)%--%ymd(2021-01-08)", correct = TRUE),
    answer("interval(ymd(2021-01-01),ymd(2021-01-08))", correct = TRUE),
    answer("ymd(2021-01-01)%within%ymd(2021-01-08)"),
    answer("ymd(2021-01-01)%--%ymd(2021-08-01)"),
    allow_retry = TRUE
  )
)
```

#### Exercices
Ecrivez un test permettant de vérifier que le 29 février 2020 se situe bien entre le 1er février 2020 et le 1er mars 2020.
```{r interval-exo1, exercise=TRUE, exercise.lines = 3}
intervalle <- interval(ymd("2020-02-01"),ymd("2020-03-01"))
test <- # ICI code pour tester l'inclusion
test
```
```{r interval-exo1-solution}
intervalle <- interval(ymd("2020-02-01"),ymd("2020-03-01"))
test <- ymd("2020-02-29") %within% intervalle
test
```

Décalez l'intervalle ci-dessous avec la fonction dédiée afin de le faire débuter au 1er juillet 2021.
```{r interval-exo2, exercise=TRUE, exercise.lines = 3}
intervalle <- interval(ymd("2020-10-01"),ymd("2020-12-30"))
intervalle_decale <- # ICI code pour décaler l'intervalle
intervalle_decale
```
```{r interval-exo2-solution}
intervalle <- interval(ymd("2020-10-01"),ymd("2020-12-30"))
intervalle_decale <- int_shift(intervalle,months(-3))
intervalle_decale
```

## Horodatage

Le package **lubridate** permet enfin d'automatiser les tâches d'horodatage, en mémorisant et appliquant automatiquement des modèles de "timbres", grâce à la fonction **stamp** :
```{r examples-stamps, echo=TRUE, comment=''}
# 1ère étape : Définition du timbre à partir d'une phrase modèle passée en paramètre
# La détection automatique est plus efficace en utilisant un jour supérieur au 12 et une année se terminant par un nombre supérieur à 31 dans le modèle
# Pour distinguer les minutes ou les secondes des heures, il est recommandé d'utiliser des nombres supérieurs à 24
timbre <- stamp("Lu et approuvé le 23 janvier 2085 à 17h30")
# 2ème étape : Application du timbre à une date passée en paramètre
# La fonction à appeler correspond au nom du timbre déterminé dans la 1ère étape
horodatage <- timbre(ymd_hm("2021-03-15 08h45"))
horodatage
```

Si le timbre d'horodatage ne contient qu'une date ou qu'une heure, l'usage des fonctions spécialisées **stamp_date** et **stamp_time** améliore encore l'efficacité de la détection automatique. En cas d'échec, il est toujours possible de préciser explicitement l'ordre attendu en paramètre supplémentaire, avec la syntaxe habituelle de description des dates :
```{r examples-stamps-ambiguous, echo=TRUE, comment=''}
# On précise explicitement l'ordre des paramètres pour éviter toute erreur
timbre2 <- stamp("Reçu à 08h30 le 03/02/20","HM dmy")
timbre2(ymd_hm("2021-04-29 22h48"))
```

#### Exercice

Définissez puis utilisez un tampon d'horodatage permattent d'écrire automatiquement la phrase "Exportation terminée le 03/06/2019 à 14:26:53"
```{r horodatage-exo, exercise=TRUE, exercise.lines = 4}
date <- ymd_hms("2019-06-03 14:26:53")
tampon <- # ICI code pour définir le tampon
horodatage <- # ICI code pour utiliser le tampon
horodatage
```
```{r horodatage-exo-solution}
date <- ymd_hms("2019-06-03 14:26:53")
tampon <- stamp("Exportation terminée le 25/02/2096 à 15:35:45")
horodatage <- tampon(date)
horodatage
```
