---
title: "Tutorial lubridate"
output: learnr::tutorial
runtime: shiny_prerendered
description: "Tutoriel dédié à l'apprentissage des bases du package de gestion des dates : lubridate"
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
```

## Introduction

Dans la plupart des logiciels et langages de programmation, le temps est considéré comme une simple valeur numérique à partir d'une date de référence.

Pour R, cette "origine des temps" est le 1er janvier 1970, 00:00:00 UTC. En revanche, LibreOffice Calc utilise le 30 décembre 1899 sous Windows et le 1er janvier 1904 sous macOS. Microsoft Excel utilise le 1er janvier 1900... ces différences d'origine complexifient le traitement des données temporelles.

Pour contourner ce problème, les indications temporelles sont souvent stockées sous un format textuel - par exemple "12/07/2014" - mais cela rend difficile la réalisation de calculs à partir de ces dates.

Les fonctionnalités de base de R permettent en partie de traiter ces questions, mais au prix de contraintes de syntaxe et d'un manque de souplesse.

Le package **lubridate** permet d'importer ou de générer des données temporelles, de réaliser des calculs de durées ou d'intervalles et d'accéder facilement aux différents éléments d'une date.

L'installation et le chargement s'effectuent à l'aide la commande suivante :

```{r installpack, message=FALSE, warning=FALSE, echo=TRUE}
#install.packages("lubridate")
library(lubridate)
```

## Importation de dates

L'importation de données temporelles avec **lubridate** s'effectue en deux temps :

* Identification de l'ordre dans lequel les éléments apparaissent dans la donnée source : année (**y**), mois (**m**), jour (**d**), heure (**h**), minute (**m**), seconde (**s**).
* Appel de la fonction de **lubridate** reprenant l'ordre de ces éléments : 
  + **ymd_hms**() - Année Mois Jour Heure Minute Seconde -
  + **dmy**() - Jour Mois Année -
  + **dmy_hms**() - Jour Mois Année Heure Minute Seconde -
  + Toute autre combinaison avec **y**, **m**, **d**, **h**, **m** et **s**.
  
Les dates retournées par toutes les fonctions de **lubridate** sont au format "yyyy-mm-dd" (dd : day, mm : month, yyyy : year).
  
**Lubridate** posède également des fonctions **now**() et **today**() donnant respectivement la date du jour avec ou sans l'heure.

### Exemples

```{r, echo=TRUE, comment=''}
date_1 <- ("25/12/2015") # Jour/Mois/Année
lubridate1 <- dmy(date_1)
lubridate1 # Notre date est bien importée au format yyyy-mm-dd

date_2 <- ("2020-24-12") # Année/Jour/Mois
lubridate2 <- ydm(date_2)
lubridate2

date_3 <- ("12 Janvier 2021 à 15:30:05") # Jour/Mois/Année/Heure/Minute/Seconde
lubridate3 <- dmy_hms(date_3)
lubridate3

now() # Date et heure actuelle
today() # Date actuelle seulement
```

### Exercices 

Pour chaque exercice, choisissez la fonction du package **lubridate** permettant l'import correct de la date. 

```{r dateimport1, exercise=TRUE, exercise.lines = 3}
date_1 <- ("13/01/2021")
lubridate1 <- # ICI code pour importer la date
lubridate1
```
```{r dateimport1-solution}
date_1 <- ("13/01/2021")
lubridate1 <- dmy(date_1)
lubridate1
```
```{r dateimport2, exercise=TRUE, exercise.lines = 3}
date_2 <- ("25-2021-10")
lubridate2 <- # ICI code pour importer la date
lubridate2
```
```{r dateimport2-solution}
date_2 <- ("25-2021-10")
lubridate2 <- dym(date_2)
lubridate2
```
```{r dateimport3, exercise=TRUE, exercise.lines = 3}
date_3 <- ("25 Février 2018 à 12H30")
lubridate3 <- # ICI code pour importer la date
lubridate3
```
```{r dateimport3-solution}
date_3 <- ("25 Février 2018 à 12H30")
lubridate3 <- dmy_hm(date_3)
lubridate3
```

```{r importquiz}
quiz(
  question("Quel est le format de date retourné par les fonctions lubridate ?",
    answer("yyyy-dd-mm"),
    answer("dd-mm-yyyy"),
    answer("yyyy-mm-dd", correct = TRUE),
    answer("dd-mm-yy"),
    allow_retry = TRUE
  )
)
```

## Conversion entre les fuseaux horaires

La liste des fuseaux horaires proposés par le package **lubridate** est disponible à l'aide de la fonction **OlsonNames()**.

L'équivalent d'une date/heure dans un autre fuseau horaire peut-être obtenu à l'aide de la fonction **with_tz**.

### Exemples

```{r, message=FALSE, warning=FALSE, echo=TRUE, comment=''}
head(OlsonNames())
```

```{r, message=FALSE, warning=FALSE, echo=TRUE, comment=''}
# Importation de la date (Cf. paragraphe précédent)
date <- dmy_hm("25 Février 2018 à 12H30")

# Conversion dans le fuseau horaire de Los Angeles
date_convertie <- with_tz(date, "America/Los_Angeles")
date_convertie

# Conversion dans le fuseau horaire de Abidjan
date_convertie2 <- with_tz(date, "Africa/Abidjan")
date_convertie2
```

### Exercices
Convertissez la date suivante dans le fuseau horaire de Asmera :
```{r dateconvert1, exercise=TRUE, exercise.lines = 3}
date_1 <- dmy_hm("25 Février 2018 à 12H30")
date_convertie_1 <- # ICI code pour convertir la date dans le fuseau horaire de Asmera
date_convertie_1
```
```{r dateconvert1-solution}
date_1 <- dmy_hm("25 Février 2018 à 12H30")
date_convertie_1 <- with_tz(date_1, "Africa/Asmera")
date_convertie_1
```
Convertissez maintenant la date dans le fuseau horaire de Los Angeles :
```{r dateconvert2, exercise=TRUE, exercise.lines = 3}
date_2 <- dmy_hm("25 Février 2018 à 12H30")
date_convertie_2 <- # ICI code pour convertir la date dans le fuseau horaire de Los Angeles
date_convertie_2
```
```{r dateconvert2-solution}
date_convertie_2 <- with_tz(date_2, "America/Los_Angeles")
date_convertie_2
```

## Manipulation des dates 

Les dates sont des objets que l'on peut manipuler. Nous pouvons accèder aux différents éléments d'une date : année, mois, jour, heure, etc. Comme tout autre objet R, nous pouvons les modifier mais également faire des calculs.

### Accès aux éléments d'une date

Dans le package `lubridate` il existe de nombreuses fonctions pour accéder aux différents éléments d'une date.

Voici une liste non exhausive des élements d'une date que l'on peut extraire :

|  Date | Annee | Mois | Semaine | Jour | Heure |
|:-----:|:-----:|:-----:|:-----:|:----:|:---:|
|`date`|`year` `leap_year` `semester` `quarter`|`month`|`week`|`day` `wday` `qday` `yday` `hour`|`minute` `second` `am` `pm` `dst`|

**Date**

* `date` : date au format année-mois-jour
* `month` : mois
* `week` : numéro de la semaine 

**Annee**

* `year` : année
* `leap_year` : est-ce une année bisextile ?
* `semester` : numéro du semestre
* `quarter` : numéro du trimestre


**Jour** 

* `hour` : heure
* `day` : jour du mois
* `wday` : jour de la semaine
* `qday` : jour du trimestre
* `yday` : jour de l'année
  

**Heure**

* `minute` : minute
* `second` : seconde
* `am` : est-ce le matin ?
* `pm` : est-ce l'après-midi ?
* `dst` : est-ce l'heure d'été ?

Toutes les fonctions prennent au moins un paramètre : une date. Par exemple si on veut utiliser la fonction heure on utilisera `hour(x)` où `x` est une date dont on veut connaître l'heure. La majorité ces fonctions partagent les mêmes paramètres que nous verrons plus loin dans cette section.

Prenons un exemple que nous garderons dans toute la suite de cette section comme le 1er septembre 1999 à 11h 59m 59s. Ici on affecte à la variable `date` la fonction suivante : `dmy_hms("01-09-1999 11:59:59")` et la convertissons en date comme vu précédemment. Par exemple, si l'on veut extraire l'heure, le jour, le numéro de la semaine et l'année du 1er septembre 1999 on utilisera les commandes suivantes :


```{r exemple-1999-09_01, include=FALSE}
exemple_date <- dmy_hms("01-09-1999 11:59:59")
```

```{r examples-data-management, echo=TRUE, include=TRUE, comment=''}
# l'heure
hour(exemple_date)
# le jour
day(exemple_date) 
# le numéro de la semaine
week(exemple_date) 
# l'année
year(exemple_date) 
```

Au lieu d'un numéro on pourrait vouloir connaître le mois ou encore le jour (en lettres). Pour cela on dispose de deux paramètres : `label` et `abbr` qui prennent en paramètre un booléen. Par défaut `label` est défini à `FALSE` et `abbr` est défini à `TRUE`. `label` permet d'afficher un texte abbrévié et `abbr` permet de dire si l'on veut que le texte soit abbrévié ou non. Mais **attention ces options ne fonctionnent pas sur toutes les fonctions**. Entre autres, ces options seront disponibles pour `wday` mais pas pour `day`. Illustrons cela par des exemples.

```{r examples-labels-abbr, echo=TRUE, comment=''}
# nombre
month(exemple_date) 
# label abrévié
month(exemple_date, label = T)
# label non abrévié
month(exemple_date, label = T, abbr = F) 
```

Cela affiche également les autres mois et l'on voit bien qu'ils sont ordonnés selon un ordre chronologique.

A cela s'ajoute deux autres options : `week_start` et `locale`. L'option `week_start` défini le début de la semaine. Par convention, -1 correspond à lundi et 7 correspond à dimanche. Quant à `locale`, il s'agit de définir les noms des jours ou mois (en fonction de la langue).

Deux fonctions ont un paramètre supplémentaire. Il s'agit des fonctions `quarter` et `semester` qui ont la syntaxe suivante : `fonction(x, with_year = FALSE)`. Le second paramètre indique si l'on veut concaténer ou non le numéro du semestre avec l'année. Par exemple, si on veut connaître le semestre du 1er janvier 2020 en utilisant `with_year = TRUE` on obtiendra 2020.1 car le 01/01/2020 est un jour du premier semestre.

Voici quelques exemples avec notre date du 01/09/1999.

```{r examples-quarter-semester, echo=TRUE, include=TRUE, comment=''}
# trimestre sans année
quarter(exemple_date, with_year = F) 
# trimestre avec année
quarter(exemple_date, with_year = T) 
# semestre sans année
semester(exemple_date, with_year = F) 
# semestre avec année
semester(exemple_date, with_year = T) 
```


On remarque que toutes les fonctions retournent un nombre qui correspond soit à un numéro soit à un nombre d'heures, de jours, etc. (ou avec un label). Seules les fonctions `leap_year`, `am`, `pm` et `dst` renvoient un booléen (`True` ou `False`) comme le montrent les exemples ci-dessous.

```{r exemples-data-management-bool, echo=TRUE, include=TRUE, comment=''}
# année bisextile ?
leap_year(exemple_date) 
# matin ?
am(exemple_date) 
# après-midi ?
pm(exemple_date) 
# heure d'été ?
dst(exemple_date) 
```


**NB** Il existe également quelques variantes pour permettre de mettre une date au format ISO comme `isoyear` ou `isomonth`.

En manipulant la fonction `month` il est également possible d'afficher tous les mois de l'année. En effet, si on prend le mois de janvier auquel on ajoute les mois restant au travers de la ligne de commande `month(dmy("01-01-2021") + months(0:11), label = T, abbr = F)`. Le resultat sera `janvier février mars avril mai juin juillet août septembre octobre novembre décembre`. Il est également possible de faire ces manipulations sur toutes les fonctions qui prennent en paramètre un label.

```{r quiz-compenents-date}
quiz(
  question("Quel(s) paramètre(s) prend la fonction `day`?",
    answer("week_start"),
    answer("label"),
    answer("une date", correct = TRUE),
    answer("locale"),
    answer("abbr"),
    allow_retry = FALSE
  ),
  question("Quel(s) paramètre(s) prend la fonction `wday`?",
    answer("week_start", correct = TRUE),
    answer("label", correct = TRUE),
    answer("une date", correct = TRUE),
    answer("locale", correct = TRUE),
    answer("abbr", correct = TRUE),
    allow_retry = FALSE
  )
)
```


#### Exercices

Ecrire la date du 15 février 1970 puis à l'aide d'une fonction extraire le mois (numéro, nom abbrévié et non abbrévié).
```{r datecomponents-ex1, exercise=TRUE, exercise.lines = 3}

```

```{r datecomponents-ex1-solution}
date_15fev1970 <- dmy("15-02-1970")
month(date_15fev1970)
month(date_15fev1970, label = T)
month(date_15fev1970, label = T, abbr = F)
```

Afficher tous les jours de la semaine à l'aide d'une commande en commençant par lundi. (*Remarque* Le 1er février 2021 est un lundi.)
```{r datecomponents-ex2, exercise=TRUE, exercise.lines = 3}

```

```{r datecomponents-ex2-solution}
wday(dmy("01-02-2021") + wday(0:6), label = T, abbr = F)
```

Extraire tous les éléments de la date du 10 décembre 1990.
```{r datecomponents-ex3, exercise=TRUE, exercise.lines = 5}
date_ex <- dmy("10-12-1990")
```

```{r datecomponents-ex3-solution}
date_ex <- dmy("10-12-1990")
day(date_ex)
month(date_ex)
year(date_ex)
```



### Modification d'une date

Tout comme on peut accéder aux éléments d'une date, on peut modifier ces éléments. Reprennons notre date exemple, imaginons que la date du 1er septembre 1999 à 11 h 59 min 59 sec est une date de réunion. Disons que la réunion était prévue le lendemain à 14 heures. Pour cela on changera les attributs `day, hour, minute` et `second`

```{r, echo=TRUE, include=TRUE, comment=''}
day(exemple_date) <- 2
hour(exemple_date) <- 14
minute(exemple_date) <- 0
second(exemple_date) <- 0
exemple_date
```

Mais on peut également utliser la fonction `update` pour affecter toutes ces modifications simultanément comme on peut le voir dans l'exemple ci-dessous.

```{r, echo=TRUE, include=TRUE, comment=''}
exemple_date <- update(exemple_date, day=2, hour=14, minute=0, second=0)
exemple_date
```

Une autre façon de modifier une date consiste à l'arrondir. Pour cela nous disposons de trois fonctions qui sont les suivantes : 

* `floor_date` qui arrondit à l'unité la plus proche par valeurs inférieures
* `round_date` qui arrondit à l'unité la plus proche 
* `ceiling_date` qui arrondit à l'unité la plus proche par valeurs supérieures

Ces trois fonctions prennent deux paramètres : une date et l'unité de l'arrondi `unit`. L'unité peut prendre plusieurs niveaux de précision : miliseconde, seconde, minute, heure, jour, semaine, mois, etc. 

```{r, echo=FALSE, include=TRUE, comment=''}
exemple_date <- dmy_hms("01-09-1999 11:59:59")
```


```{r, echo=TRUE, include=TRUE, comment=''}
# par défaut
round_date(exemple_date)

# arrondi de l'heure par valeurs inférieures
floor_date(exemple_date, unit = "hour")

# arrondi de l'heure à la valeur la plus proche
round_date(exemple_date, unit = "hour")

# arrondi de l'heure par valeurs supérieures
ceiling_date(exemple_date, unit = "hour")
```

On peut même aller plus loin dans la précision en spécifiant le nombre de l'unité : 10 secondes, 5 minutes, 2 heures, 3 mois et ainsi de suite comme illustré dans les exemples ci-dessous. Pour arrondir aux millisecondes près on ajoute 32 secondes à notre date.

```{r, echo=TRUE, include=TRUE, comment=''}
x <- ymd_hms("1999-09-01 11:59:59.32")

# arrondi aux 5 millièmes de secondes
round_date(x, ".5s")

# arrondi aux 5 minutes près 
round_date(x, "5 mins")

# arrondi à 5 heures près par valeurs supérieures
ceiling_date(x, "5 hours")
```

Cette fonction permet une granularité encore plus fine notamment via des arrondis bimensuels, semestriels, trimestriels, biannuels et annuels comme dans les exemples ci-dessous. On peut même vérifier qu'un arrondi par trimestre correspond à un arrondi tous les 3 mois.

```{r, echo=TRUE, include=TRUE, comment=''}
# arrondi bimensuel
round_date(x, "bimonth")

# vérification que : arrondi trimestrielle = arrondi tous les trois mois
round_date(x, "quarter") == round_date(x, "3 months")

# arrondi biannuel
round_date(x, "halfyear")
```

```{r quiz-round-date}
quiz(
  question("Nous avons décidé d'arrondir la date `1999-09-01 11:59:50 UTC` et nous obtenons `2000-01-01 UTC`. Quelle(s) commande(s) permettent ce résultat ?",
    answer('floor_date(exemple_date, unit = "year")'),
    answer('round_date(exemple_date, unit = "year")', correct = TRUE),
    answer('ceiling_date(exemple_date, unit = "year")', correct = TRUE),
    answer('round_date(exemple_date, unit = "month")'),
    answer('round_date(exemple_date, unit = "quarter")'),
    answer('round_date(exemple_date, unit = "halfyear")'),
    allow_retry = FALSE
  ),
  question('Avec la même date nous arrondissons via la commande `round_date(exemple_date, unit = "halfyear")`. Quel est le résultat obtenu ?',
    answer('1999-06-01 UTC'),
    answer('1999-07-01 UTC', correct = TRUE),
    answer('1999-09-01 UTC'),
    answer('1999-12-01 UTC'),
    answer('2000-01-01 UTC'),
    allow_retry = FALSE
  )
)
```

#### Exercices

Une personne a mis la date du 29 février 2000 alors qu'il s'agissait du 1er mars. Modifier la date en conséquence sans utiliser la fonction `update`.
```{r datemodif-ex1, exercise=TRUE, exercise.lines = 5}
date_ex1 <- dmy("29-02-2000")
```

```{r datemodif-ex1-solution}
date_ex1 <- dmy("29-02-2000")
day(date_ex1) <- 1
month(date_ex1) <- 3
date_ex1
```

Effectuer les mêmes modifications qu'à la question précédente mais via la fonction `update`.
```{r datemodif-ex2, exercise=TRUE, exercise.lines = 3}
date_ex2 <- dmy("29-02-2000")

```

```{r datemodif-ex2-solution}
date_ex2 <- dmy("29-02-2000")
date_ex2 <- update(date_ex1, day = 1, month = 3)
date_ex2
```

Ecrire la date suivante : `3 février 2017 à 16h 15m 32s` puis trouver comment l'arrondir de telle sorte qu'on obtienne `2017-02-03 18:00:00 UTC`. 

```{r datemodif-ex3, exercise=TRUE, exercise.lines = 3}
date_ex3 <- dmy("")

```

```{r datemodif-ex3-solution}
date_ex3 <- dmy_hms("03-02-2017 16:15:32")
ceiling_date(date_ex3, unit = "2 hours")

```

Exemples de manipulations de dates

`today()`


### Calculs avec des dates (Maxence)

## Horodatage (Maxence)
